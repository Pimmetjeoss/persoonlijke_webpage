"use client"

import { useState, useCallback, useRef, useEffect } from "react"

const CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*"

interface TextScrambleProps {
  text: string
  className?: string
  /** Trigger scramble externally (e.g., parent hover state) */
  trigger?: boolean
  /** Style to apply to the container */
  style?: React.CSSProperties
}

export function TextScramble({ text, className = "", trigger, style }: TextScrambleProps) {
  const [displayText, setDisplayText] = useState(text)
  const [isScrambling, setIsScrambling] = useState(false)
  const intervalRef = useRef<NodeJS.Timeout | null>(null)
  const frameRef = useRef(0)
  const hasTriggeredRef = useRef(false)

  const scramble = useCallback(() => {
    setIsScrambling(true)
    frameRef.current = 0
    const duration = text.length * 3

    if (intervalRef.current) clearInterval(intervalRef.current)

    intervalRef.current = setInterval(() => {
      frameRef.current++

      const progress = frameRef.current / duration
      const revealedLength = Math.floor(progress * text.length)

      const newText = text
        .split("")
        .map((char, i) => {
          if (char === " ") return " "
          if (i < revealedLength) return text[i]
          return CHARS[Math.floor(Math.random() * CHARS.length)]
        })
        .join("")

      setDisplayText(newText)

      if (frameRef.current >= duration) {
        if (intervalRef.current) clearInterval(intervalRef.current)
        setDisplayText(text)
        setIsScrambling(false)
      }
    }, 30)
  }, [text])

  // Handle external trigger
  useEffect(() => {
    if (trigger && !hasTriggeredRef.current) {
      hasTriggeredRef.current = true
      scramble() // eslint-disable-line react-hooks/set-state-in-effect
    }
    if (!trigger) {
      hasTriggeredRef.current = false
    }
  }, [trigger, scramble])

  // Handle internal hover when no external trigger is provided
  const handleMouseEnter = () => {
    if (trigger === undefined) {
      scramble()
    }
  }

  useEffect(() => {
    return () => {
      if (intervalRef.current) clearInterval(intervalRef.current)
    }
  }, [])

  return (
    <span
      className={className}
      style={style}
      onMouseEnter={handleMouseEnter}
    >
      {displayText.split("").map((char, i) => (
        <span
          key={i}
          className="inline-block"
          style={{
            transition: "transform 150ms ease",
            transitionDelay: `${i * 10}ms`,
            transform: isScrambling && char !== text[i] ? "scale(1.05)" : "scale(1)",
          }}
        >
          {char}
        </span>
      ))}
    </span>
  )
}
